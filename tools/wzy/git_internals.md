# Git 原理

> Git 不仅是一个分布式版本管理系统（Distributed Version Control System， DVCS），还是一个内容寻址（content-addressable）文件系统，它在内容的存储和管理方式上和其他版本管理系统（如SVN）有很大的差异。要掌握`Git`，最根本的就是要理清，它是如何管理文件的。

## 基本原理

### 关于版本控制

1. 本地版本控制

利用某种简单的数据库来记录文件历次更新的差异

![](./images/local.png)

2. 集中化的版本控制

为了让不同系统上的开发者协同工作，所以就有了集中化的版本控制系统。

> 集中化的版本控制都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新

![](./images/centralized.png)

相比于本地版本控制，集中化版本控制有一个单一服务器，更便于管理。缺点是单个服务器故障的情况下，就无法提交更新了。同时中心数据库发生损坏，又没备份的话，就丢失所有的数据，只剩开发者机器上的快照版本。

3. 分布式版本控制系统

![](./images/distributed.png)

分布式版本控制系统的客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来，包括完整的历史记录。

### 记录快照，而非差异
SVN等类似的工具，是基于差异（delta-based）的版本控制系统，存储的是文件各个版本之间的差异内容

![](./images/deltas.png)

Git更像是一个小型的文件管理系统，存储的是文件的快照。每单提交更新时，都会对修改的文件生成一个新的快照。 Git 对待数据更像是一个**快照流**。

> 也就是说如果文件没有改变，就不会生成新快照。

![](./images/snapshots.png)

### 三个阶段和文件状态
针对文件的暂存(`add`)、提交(`commit`)等操作都会在`.git/objects`下生成相应类型Git对象。这些对象保存了不同阶段的文件信息，同时通过文件状态可以辨别文件所处的阶段。接下来我们看下GIT的三个阶段和文件状态的关系。

![](./images/phase.drawio.png)


* 工作区(Working directory)：当前从某个版本检出的工作区的目录，也就是我们编辑的源文件
    * `untracked(未跟踪)`：新增的文件
    * `modified(已修改)`：修改的文件，但还没保存到数据库中。
* 暂存区(Staging area)：暂存区是一个文件，保存了下次将要提交的文件列表信息
    * `staged(已暂存)`：对新增和修改的文件的当前版本做了标记，使之可以包含在下次提交的中
* Git本地仓库当前分支(Head)
    * `committed(已提交)`：数据已经安全地保存在本地数据库中

## 内部原理

### Git对象
前面说到Git是一个内容寻址文件系统，它的核心部分是一个简单的键值对象数据库（key-value data store）。你可以向 Git 仓库中插入任意类型的内容，它会返回一个唯一的键(SHA-1 哈希值)，通过该键可以在任意时刻再次取回该内容。

上面所说的文件快照最终就是存储在这个对象数据库中(即`.git/objects`目录)。在存储时，它们会被转换成Git对象，然后生产一个唯一SHA-1哈希值。在了解`.git`目录之前，我们先了解这些Git对象
* `数据对象(blob object)`：文件快照内容
* `树对象(tree object)`：用于组织不同文件快照之间的关系，形成一种树形结构，和我们的文件目录结构类似
* `提交对象(commit object)`：记录每次提交时的基本信息，包含提交者信息、提交注释、提交时间和提交的内容(指向的某个树对象)

### .git目录

接下来，我们来看下`.git`文件夹的结构，做一个整体的了解

```
.git
└── hooks/
└── info/
└── logs/
    └── refs/
└── objects/
    ├── pack/
    ├── info/
    └── ...
└── refs
    ├── heads/
        ├── master
        ├── develop
        └── ...
    ├── remotes/
    └── tags/
└── config
└── description
└── HEAD
└── index

```
* `objects`目录存储所有数据内容（`对象数据库`），文件快照和一些操作记录都会以Git对象的方式存储在这。另外，Git为了节省存储对象所占用的磁盘空间，会对Git对象进行压缩和打包，其中
    * `pack`文件夹用于存储打包压缩的对象，而
    * `info`文件夹用于从打包的文件中查找git对象；
* `HEAD`文件指向目前正在使用的代码分支，比如当前分支是`master`，则该文件就会指向`master`
* `index`文件保存暂存区(Staging area)信息。
* `refs`目录存储本地分支、远程分支、标签的最近一次的`commit对象`指针
    * `heads`目录记录了本地每一个分支最近一次commit对象的指针；
    * `remotes`目录存储记录每个分支和远程仓库分支的最后一次的通信指针
* `logs`目录记录了本地仓库和远程仓库的每一个分支的提交记录
* `config`文件包含项目的一些配置信息，例如仓库地址、是否开启大小写铭感等
* `hooks`客户端和服务端钩子函数，利用这些钩子可以做很多的事情，比如提交时的代码检查和提交message检查等。

可以看到，一个仓库的所有信息，都存储于这个`.git`目录下。而`objects`作为基础和核心，提供了最基本的数据存储能力。

### 底层命令
Git本身提供了一系列的底层命令，来进行快照文件的管理，完成Git的底层工作，。底层命令包含`git hash-object`、`git update-index `、`git write-tree`、`git commit-tree`等，这些底层命令的执行直接影响到`.git`文件夹下的内容。如果要了解更多的底层命令的使用，[点击这里](https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-Git-%E5%AF%B9%E8%B1%A1)

相对于底层子命令的是上层命令，也就是我们平时直接使用的命令，如`checkout`、`branch`、`log`、`merge`等，这些命令通常就是调用的底层命令来实现相应的能力，是对底层命令的二次封装，对用户更为友好且易懂。

除了直接使用上层命令外，还可以使用目前网络上的一些GUI工具来管理git仓库，进一步降低学习成本。它们之间的关系大致如下所示

![](./images/git.drawio.png)

### 维护和数据恢复

#### 维护

Git 会不定时地自动运行一个叫做 “auto gc” 的命令。它会运行一个完整的``git gc``命令。gc 会做以下事情：

1. 收集所有松散对象（不在包文件中的对象）并将它们放置到包文件中
2. 将多个包文件合并为一个大的包文件
3. 移除与任何提交都不相关的陈旧对象

> Git 最初向磁盘中存储对象时所使用的格式被称为“松散（loose）”对象格式

#### 恢复

在你使用 Git 的时候，你可能会意外丢失一次提交。 通常这是因为你强制删除了正在工作的分支，但是最后却发现你还需要这个分支， 亦或者硬重置了一个分支，放弃了你想要的提交。

使用一个名叫 git reflog 的工具。 当你正在工作时，Git 会默默地记录每一次你改变 HEAD 时它的值。

## 参考资料
* [git book](https://git-scm.com/book/en/v2)